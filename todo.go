package main 

import (
	"os"
	"net/http"
	"log"
	"strings"
	"fmt"
	//"io"
	/*  _ It's for importing a package solely for its side-effects.
		In the case of go-sqlite3, the underscore import is used for the side-effect of registering 
	    the sqlite3 driver as a database driver in the init() function, without importing any other functions 
			sql.Register("sqlite3", &SQLiteDriver{})

		Once it's registered in this way, sqlite3 can be used with the standard library's 
		sql interface in your code like in the example:
			db, err := sql.Open("sqlite3", "./foo.db")
	*/
	_ "github.com/mattn/go-sqlite3"
	"database/sql"
	"github.com/gorilla/mux"
	"encoding/json"
	"github.com/elgs/gosqljson"
	//"bytes"
)

// This function is of type http.HandlerFunc
/*
	type Handler interface {
	    ServeHTTP(ResponseWriter, *Request)
	}
*/
// Each http.Handler implementation can be thought of as its own web server.
func handlerItems(w http.ResponseWriter, r *http.Request){
	// http.ResponseWriter assembles the HTTP's server response
	// By writing to it, we send data to the HTTP client
	/*
		type ResponseWriter interface {
 		    Header() Header
		    Write([]byte) (int, error)
		    WriteHeader(int)
		}
	*/

	// http.Request is a data structure that represents the client HTTP request 
	// r.URL.path is the path component of the request URL
}


func NewDB() *sql.DB {
    db, err := sql.Open("sqlite3", "./todo.db")
    checkErr(err)
    
    /*
    _, err = db.Exec("DROP TABLE todoitems")
    checkErr(err)
    */

    _, err = db.Exec("CREATE TABLE IF NOT EXISTS todoitems(id integer primary key autoincrement, name text, dueDate text, priority text, description text, completed int)")
    checkErr(err)

    return db
}

func AddItem(db *sql.DB) http.Handler{
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	 	err := r.ParseForm()
		checkErr(err)

		todoName := r.PostFormValue("name")
		todoDueDate := r.PostFormValue("dueDate")
		todoPriority := r.PostFormValue("priority")
		todoDescription := r.PostFormValue("description")
		todoCompleted := r.PostFormValue("completed")

		fmt.Println(r.Form)

	 	// Insert 
		stmt, err := db.Prepare("INSERT INTO todoitems (name, dueDate, priority, description, completed) VALUES(?, ?, ?, ?, ?)")
		checkErr(err)
		
		res, err := stmt.Exec(todoName, todoDueDate, todoPriority, todoDescription, todoCompleted)
		checkErr(err)

		// LastInsertId returns the integer generated by the database
        // in response to a command. Typically this will be from an
        // "auto increment" column when inserting a new row. Not all
        // databases support this feature, and the syntax of such
        // statements varies.
        id, err := res.LastInsertId(); 
        checkErr(err)

        //io.WriteString()

        // Set content-type header to JSON
        w.Header().Set("Content-Type", "application/json")

	    response := map[string]int{"id": int(id)}
	    jsonResponse, err := json.Marshal(response)
	    checkErr(err)

	    //json.NewEncoder(w).Encode(jsonresponse)
	    w.Write(jsonResponse)
	})
}

type TodoItem struct {
	id 				int
	name 			string
	dueDate 		string
	priority 		string
	description 	string 
}

func ReadItems(db *sql.DB) http.Handler{
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		/*
		rows, err := db.Query("SELECT * FROM todoitems")
		checkErr(err)
		*/
		/*
			A defer statement pushes a function call onto a list. 
			The list of saved calls is executed after the surrounding function returns. 
			Defer is commonly used to simplify functions that perform various clean-up actions.
		*/
		//defer rows.Close()

		/*
		var result []TodoItem
		for rows.Next() {
			item := TodoItem{}
			err := rows.Scan(&item.id, &item.name, &item.dueDate, &item.priority, &item.description)
			checkErr(err)
			result = append(result, item)
			json.NewEncoder(w).Encode(item)
		}
		*/
		w.Header().Set("Content-Type", "application/json")	

		data, err := gosqljson.QueryDbToMap(db, "", "SELECT * FROM todoitems")
		checkErr(err)

		json.NewEncoder(w).Encode(data)	
	})
}

func DeleteItem(db *sql.DB) http.Handler{
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		err := r.ParseForm()
		checkErr(err)

		split := strings.Split(r.URL.String(), "/")
		id := split[len(split) - 1]

		stmt, err := db.Prepare("DELETE FROM todoitems WHERE id=?")
		checkErr(err)
		
		_, err = stmt.Exec(id)
		checkErr(err)
	})
}

func UpdateItem(db *sql.DB) http.Handler{
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		err := r.ParseForm()
		checkErr(err)

		split := strings.Split(r.URL.String(), "/")
		id := split[len(split) - 1]

		/*
		var buffer bytes.Buffer

		for key, val := range r.Form {
			buffer.WriteString(key)
			buffer.WriteString(" = ")
			buffer.WriteString(val)
			buffer.WriteString(", ")
		}

		buffer.TrimSuffix(buffer, ", ")
		*/

		todoName := r.FormValue("name")
		todoDueDate := r.FormValue("dueDate")
		todoPriority := r.FormValue("priority")
		todoDescription := r.FormValue("description")
		todoCompleted := r.FormValue("completed")

		stmt, err := db.Prepare("UPDATE todoitems SET name=?, dueDate=?, priority=?, description=?, completed=? WHERE id=?")
		checkErr(err)

		_, err = stmt.Exec(todoName, todoDueDate, todoPriority, todoDescription, todoCompleted, id)
		checkErr(err)
	})
}

func checkErr(err error){
	if err != nil {
		/* Panic is a built-in function that stops the ordinary flow of control and begins panicking. 
		When the function F calls panic, execution of F stops, any deferred functions in F are executed normally, 
		and then F returns to its caller. To the caller, F then behaves like a call to panic. 
		The process continues up the stack until all functions in the current goroutine have returned, 
		at which point the program crashes.
		*/
        panic(err)
    }
}

func main(){
	port := os.Getenv("PORT") 

	if port == "" {
		port = "3000"
	}

	db := NewDB()

	//http.Handle("/", http.FileServer(http.Dir("./public")))

	r := mux.NewRouter()

	// Handle all requests to the web root w/ passed in function, handler
	r.Handle("/todoitems", AddItem(db)).Methods(http.MethodPost)
	r.Handle("/todoitems", ReadItems(db)).Methods(http.MethodGet)
	r.Handle("/todoitems/{id}", DeleteItem(db)).Methods(http.MethodDelete)
	/* 
		PUT is used when you know the url of the item being created
		Decide to use PUT or POST based on idempotence (Putting an object 2x has no effect)
	*/
	r.Handle("/todoitems/{id}", UpdateItem(db)).Methods(http.MethodPut)

	// This will serve files under http://localhost:3000/<filename> - Serves CSS, JS files 
	r.PathPrefix("/").Handler(http.StripPrefix("/", http.FileServer(http.Dir("./public"))))

	log.Println("Listening...")

	// Used to start the server 
	// When it receives an HTTP request, it will hand it off to the http.Handler that we supply as the second argument
	/* 
		The http.FileServer function builds an http.Handler that will serve an entire directory of files 
		and figure out which file to serve based on the request path. 
	*/
	// We told the FileServer to serve the current working directory with http.Dir(".").
	// nil -> use DefaultServeMux (default HTTP request router)
	/* 
		ServeMux: Compares incoming requests against a list of predefined URL paths, and 
		calls the associated handler for the path whenever a match is found.
	*/
	/*	
		type ServeMux struct {
		    mu sync.RWMutex   // because of concurrency, we have to use a mutex here
		    m  map[string]muxEntry  // router rules, every string mapping to a handler
		}
	*/
	// Handle and HandleFunc add handlers to DefaultServeMuxs
	// Handlers are responsible for writing response headers and bodies.
	http.ListenAndServe(":" + port, r)
}